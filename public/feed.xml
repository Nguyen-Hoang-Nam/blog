<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
	<channel>
		<title>DevOT blog</title>
		<link>https://devot.netlify.app/</link>
		<description>Recent content on DevOT blog</description>
		<generator>Hugo -- gohugo.io</generator>
		<language>en-us</language>
		<lastBuildDate>Thu, 10 Mar 2022 10:00:00 +0700</lastBuildDate>
		
		<atom:link href="https://devot.netlify.app/feed.xml" rel="self" type="application/rss+xml" />
		
		
		<item>
			<title>Cùng nhau chặn Spam bằng Python nào</title>
			<link>https://devot.netlify.app/posts/filter-spam-in-python/</link>
			<pubDate>Thu, 10 Mar 2022 10:00:00 +0700</pubDate>
			
			<guid>https://devot.netlify.app/posts/filter-spam-in-python/</guid>
			<description>&lt;p&gt;&amp;ldquo;Bạn vừa trúng một chiếc IPhone&amp;rdquo;, &amp;ldquo;Ban là người may mắn thứ 101&amp;rdquo; những câu nói này nghe quen với bạn chứ. Trong bài viết
nhỏ này, mình sẽ hướng dẫn cách để tạo ra một hệ thống chống Spam nho nhỏ. Mình thấy bài viết cũng rất phù hợp với các
bạn muốn tìm hiểu về xử lý ngôn ngữ tự nhiên (NLP).&lt;/p&gt;
&lt;p&gt;Để bạn có thể đọc bài viết một cách hiệu quả nhất việc biết 1 chút Python cũng như Google Colab chắc chắn là một lợi thế.
Nếu không thì các bạn cũng yên tâm, mình sẽ giải thích kĩ từng phần.&lt;/p&gt;
&lt;h2 id=&#34;một-chút-chuẩn-bị&#34;&gt;
    
        &lt;a href=&#34;#m%e1%bb%99t-ch%c3%bat-chu%e1%ba%a9n-b%e1%bb%8b&#34;&gt;#&lt;/a&gt;
        Một chút chuẩn bị
    
&lt;/h2&gt;
&lt;p&gt;Đối với các bạn nào chưa từng thử xử lý ngôn ngữ tự nhiên, thì mình nghĩ phần này có thể cho bạn một vài cái nhìn tổng
quát về những thứ mình chuẩn bị làm. Với các bạn đã nắm sơ ý tưởng, ta có thể xem từ chương kế tiếp.&lt;/p&gt;
&lt;p&gt;Trước hết cùng mình phân tích đề tài này nha. Việc chặn Spam thực chất quy về việc xác định một đoạn Text là Spam. Oki,
có vẻ hợp lý nhưng làm sao để xác định đây là Spam nhỉ? Thì xác định Spam có thể hiểu là phần dữ liệu thành những tin
nhắn Spam và không Spam (mà mình tạm gọi là Ham).&lt;/p&gt;
&lt;p&gt;Oki vậy chắc bạn sẽ thắc mắc thế nào là Spam, nào là Ham. Thú thật mình cũng không có câu trả lời đâu 😅, mà thực ra
việc hệ thống bạn xác định đó Spam hay không phụ thuộc vào việc đánh nhãn mà mình sẽ nói ở dưới, nên nếu bạn cần tìm
tiêu chí để xác định Spam hay Ham thì bạn có thể hỏi người đánh nhãn nha 😅. Vì vậy có cơ hội bạn nên trưc tiếp thu
nhập dữ liệu và đánh nhãn nha.&lt;/p&gt;
&lt;p&gt;Để thực hiện việc phân loại dữ liệu dạng Text thì xử lý ngôn ngữ tự nhiên thường theo một quy trình như sau:&lt;/p&gt;
&lt;p&gt;  
&lt;figure&gt;
    &lt;figure&gt;
        &lt;img
            class=&#34;lozad&#34;
            data-src=&#34;diagram1.png&#34;
            alt=&#34;Diagram 1&#34;
            width=&#34;761&#34;
            height=&#34;121&#34;
        /&gt;
        &lt;figcaption&gt;Quy trình xử lý ngôn ngữ tự nhiên đơn giản&lt;/figcaption&gt;
    &lt;/figure&gt;
    
&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;Cùng mình đi qua cái quy trình này xíu nha. Thu thập dữ liệu, đây là bước tiên quyết mà bạn cần phải làm, lý do là vì
dữ liệu là đầu vào của việc huấn luyện. Đánh nhãn, đây cũng là một bước cực kì quan trọng, do dữ liệu bạn thu nhập
được ở bước 1 không đủ thông tin để có thể Training được, nó cũng giống như bạn in sách giáo khoa và bỏ hết đề mục
vậy.&lt;/p&gt;
&lt;p&gt;Tin mình đi, nếu bạn làm được 2 bước này là bạn đã làm hết những việc nặng rồi đó do nó thường tốn rất nhiều thời gian.
Vì lý do này những trang Web lưu dữ liệu được đánh nhãn sản ra đời như &lt;a href=&#34;https://www.kaggle.com/&#34;&gt;Kaggle&lt;/a&gt;, nhờ đó giảm
bớt thời gian khi bạn cần thực hiện những Task đơn giản.&lt;/p&gt;
&lt;p&gt;Ta tiếp tục với việc tiền xử lý, dù dữ liệu đã được đánh nhãn, thông tin trong dữ liệu đó vấn chứa những thông tin nhiễu
cũng như đôi khi dữ liệu quá lớn cũng làm chậm quá trình huấn luyện. Tiền xử lý giúp ta loại bớt thông tin không cần thiết
từ đó đạt được dữ liệu tốt hơn cũng như nhẹ hơn.&lt;/p&gt;
&lt;p&gt;Từ nãy tới giờ, chúng ta vẫn chưa hề liên kết các thông tin lại với nhau, các đoạn Text đối với máy tính đều rời rạc
nhau. Để giải quyết vấn đề này ta cần làm bước trích xuất dữ liệu mà thực chất là liên kết các từ cũng như các đoạn
Text với nhau để tìm ra đặc trưng. Ngoài việc tìm đặc trưng thì ta cũng cần cái đầu ra là những Vector để có thể tiếp
tục bước kế tiếp.&lt;/p&gt;
&lt;p&gt;Bước cuối cùng có vẻ khó nhất nhưng thực ra ta thường thực hiện rất nhanh đó là việc phân loại dựa vào đặc trưng mà ta
tìm được ở bước trên.&lt;/p&gt;
&lt;h2 id=&#34;bắt-đầu-thôi&#34;&gt;
    
        &lt;a href=&#34;#b%e1%ba%aft-%c4%91%e1%ba%a7u-th%c3%b4i&#34;&gt;#&lt;/a&gt;
        Bắt đầu thôi
    
&lt;/h2&gt;
&lt;h3 id=&#34;chuẩn-bị-dữ-liệu-có-nhãn&#34;&gt;
    
        &lt;a href=&#34;#chu%e1%ba%a9n-b%e1%bb%8b-d%e1%bb%af-li%e1%bb%87u-c%c3%b3-nh%c3%a3n&#34;&gt;#&lt;/a&gt;
        Chuẩn bị dữ liệu có nhãn
    
&lt;/h3&gt;
&lt;p&gt;Như mình có đề cập ở trên bước này sẽ tốn tương đối nhiều thời gian, nên mình sẽ dùng một bộ dữ liệu có sẵn nha, nhưng
mình chưa tìm thấy bộ dữ liệu có sẵn Tiếng Việt nên ta dùng bộ dữ liệu Tiếng Anh nha. Bạn truy cập vào link sau &lt;a href=&#34;https://www.kaggle.com/uciml/sms-spam-collection-dataset&#34;&gt;Kaggle&lt;/a&gt;, tải về rồi upload lại lên Drive của bạn nha. Xong bước trên thì cùng mình tới phần code nào.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span class=&#34;kn&#34;&gt;from&lt;/span&gt; &lt;span class=&#34;nn&#34;&gt;google.colab&lt;/span&gt; &lt;span class=&#34;kn&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;drive&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;drive&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;mount&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;/content/drive&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Dòng Code này sẽ giúp bạn liên kết Colab và Drive của bạn vì bạn đang lưu bộ dữ liệu trên Drive. Sau đó cùng mình xem
qua một vài dòng trong dự liệu nha.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span class=&#34;n&#34;&gt;sms&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;pd&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;read_csv&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;/content/drive/MyDrive/Dev/Spam/spam.csv&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;encoding&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;latin-1&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;sms&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;sms&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;drop&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;([&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;Unnamed: 2&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;Unnamed: 3&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;Unnamed: 4&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;],&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;axis&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;sms&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;sms&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;rename&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;columns&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;v1&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;label&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;v2&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;message&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;})&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;sms&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;head&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;10&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;  
&lt;figure&gt;
    &lt;figure&gt;
        &lt;img
            class=&#34;lozad&#34;
            data-src=&#34;table1.png&#34;
            alt=&#34;Table 1&#34;
            width=&#34;445&#34;
            height=&#34;354&#34;
        /&gt;
        &lt;figcaption&gt;10 dòng đầu tiên của bộ dữ liệu&lt;/figcaption&gt;
    &lt;/figure&gt;
    
&lt;/figure&gt;
&lt;/p&gt;
&lt;h3 id=&#34;tiền-xử-lý&#34;&gt;
    
        &lt;a href=&#34;#ti%e1%bb%81n-x%e1%bb%ad-l%c3%bd&#34;&gt;#&lt;/a&gt;
        Tiền xử lý
    
&lt;/h3&gt;
&lt;h4 id=&#34;bỏ-đấu-câu-nha&#34;&gt;
    
        Bỏ đấu câu nha
    
&lt;/h4&gt;
&lt;p&gt;Bước đầu tiên trong quá trình, mình nghĩ chúng ta nên bỏ đấu câu do nội dung tin nhắn Spam thường vẫn được giữ nguyên
khi bỏ dấu câu đi. Ảnh hưởng lớn nhất của quyết định này là thay đổi ngữ pháp của câu điều mà điều mà ta không xét
tới trong bài toán này.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span class=&#34;kn&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;nn&#34;&gt;string&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;text&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;text&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;translate&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;text&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;maketrans&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;s1&#34;&gt;&amp;#39;&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;string&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;punctuation&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;))&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Mình giải thích xíu nha, hàm &lt;code&gt;maketrans&lt;/code&gt; thường đi chung với hàm &lt;code&gt;translate&lt;/code&gt; để thay thế các kí tự với tham số
đầu tiên là kí tự cần đổi, tham số kế là kí tự được đổi thành và tham số cuối là kí tự cần loại bỏ. Còn &lt;code&gt;string.punctuation&lt;/code&gt;
sẽ cho ta một chuỗi các đấu câu như sau &lt;code&gt;!&amp;quot;#$%&amp;amp;&#39;()*+,-./:;&amp;lt;=&amp;gt;?@[\]^_`{|}~&lt;/code&gt;&lt;/p&gt;
&lt;h4 id=&#34;bỏ-stop-words&#34;&gt;
    
        Bỏ Stop Words
    
&lt;/h4&gt;
&lt;p&gt;Bước thứ 2 thì không hiển nhiên lắm, Stop Words là các từ ít hỗ trợ nghĩa trong câu, chúng đôi khi đóng góp vào ngữ
pháp cho câu, đôi khi dùng để mang sắc thái biểu cảm. Nhưng chủ yếu là chúng không làm thay đổi quá nhiều nội dung
của câu khi có hoặc không có chúng, điều đó giúp ta có thể làm tập dữ liệu gọn hơn, Training nhanh hơn nhưng vẫn
cho kết quả tốt.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span class=&#34;kn&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;nn&#34;&gt;nltk&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;nltk&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;download&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;stopwords&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;

&lt;span class=&#34;n&#34;&gt;text&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;word&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;word&lt;/span&gt; &lt;span class=&#34;ow&#34;&gt;in&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;text&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;split&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;word&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;lower&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;ow&#34;&gt;not&lt;/span&gt; &lt;span class=&#34;ow&#34;&gt;in&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;stopwords&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;words&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;english&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Trong đoạn code ở trên thì 2 dòng đầu có nhiệm vụ load danh sách Stop Words cho bạn. Một lưu ý nhỏ cho bạn là
danh sách Stop Words thường không duy nhất, do đó nếu bạn tìm thấy một danh sách khác thì bạn cũng thử nha
biết đâu sẽ cho một kết quả tốt hơn.&lt;/p&gt;
&lt;h3 id=&#34;trích-xuất-đặc-trưng&#34;&gt;
    
        &lt;a href=&#34;#tr%c3%adch-xu%e1%ba%a5t-%c4%91%e1%ba%b7c-tr%c6%b0ng&#34;&gt;#&lt;/a&gt;
        Trích xuất đặc trưng
    
&lt;/h3&gt;
&lt;p&gt;Khác với quá trình tiền xử lý, bước này thường ảnh hưởng rất lớn tới kết quả cũng như việc chọn thuật toán ở dưới
để phân loại. Do bài viết này mang tính giới thiệu thôi nên mình sẽ chọn phương pháp TF-IDF để rút trích đặc trưng.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span class=&#34;kn&#34;&gt;from&lt;/span&gt; &lt;span class=&#34;nn&#34;&gt;sklearn.feature_extraction.text&lt;/span&gt; &lt;span class=&#34;kn&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;TfidfVectorizer&lt;/span&gt;
&lt;span class=&#34;kn&#34;&gt;from&lt;/span&gt; &lt;span class=&#34;nn&#34;&gt;sklearn.model_selection&lt;/span&gt; &lt;span class=&#34;kn&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;train_test_split&lt;/span&gt;

&lt;span class=&#34;n&#34;&gt;vectorizer&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;TfidfVectorizer&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;tfidf_features&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;vectorizer&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;fit_transform&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;text_feat&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;

&lt;span class=&#34;n&#34;&gt;features_train&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;features_test&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;labels_train&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;labels_test&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;train_test_split&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;tfidf_features&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;labels&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;test_size&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mf&#34;&gt;0.3&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;random_state&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;111&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Chi tiết phương pháp TF-IDF mình nghĩ xứng đáng có một bài viết riêng nền mình sẽ không trình bày ở đây. Trong đoạn
Code thì 2 dòng đầu sử dụng thư viện &lt;code&gt;sklearn&lt;/code&gt; để lấy hàm &lt;code&gt;TfidfVectorizer&lt;/code&gt; và một hàm khác làm nhiệm vụ
tách tập đặc trưng thành 2 để Train và Test. Tiếp theo đó t gọi hàm &lt;code&gt;TfidfVectorizer&lt;/code&gt; và hàm &lt;code&gt;fit_transform&lt;/code&gt;
để chuyển dữ liệu dạng những dòng chữ thành Vector. Cuối cùng ta phân các Vector đặc trưng này thành Train và Test.&lt;/p&gt;
&lt;h3 id=&#34;phân-loại&#34;&gt;
    
        &lt;a href=&#34;#ph%c3%a2n-lo%e1%ba%a1i&#34;&gt;#&lt;/a&gt;
        Phân loại
    
&lt;/h3&gt;
&lt;p&gt;Oki bước cuối rồi nè, khác với những bước trên bước này có khá nhiều cách thực hiện chúng khác nhau chủ yếu ở thuật
toán được cài đặt. Thực tế cho thấy với các rút trích đặc trưng bằng TF-IDF thì thuật toán phân loại Naive Bayes cho
kết quả tốt nhất. Nên trong phần này mình sẽ sử dụng thuật toán này nha.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span class=&#34;kn&#34;&gt;from&lt;/span&gt; &lt;span class=&#34;nn&#34;&gt;sklearn.naive_bayes&lt;/span&gt; &lt;span class=&#34;kn&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;MultinomialNB&lt;/span&gt;

&lt;span class=&#34;n&#34;&gt;mnb&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;MultinomialNB&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;alpha&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mf&#34;&gt;0.2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;mnb&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;fit&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;feature_train&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;labels_train&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;pred&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;mnb&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;predict&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;features_test&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;pred_scores&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;accuracy_score&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;label_test&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;pred&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Các bạn chắc cũng nắm được dòng đầu rồi ha, nó lấy cho ta hàm &lt;code&gt;MultinomiaNB&lt;/code&gt; mà dễ hiểu là thuật toán Naive Bayes.
Ở phần kế ta khởi tạo thuật toán với tham số &lt;code&gt;alpha=0.2&lt;/code&gt;, hàm &lt;code&gt;fit&lt;/code&gt; giúp thuật toán sử dụng đặc trưng mà bạn
rút trích để Train thuật toán và hàm &lt;code&gt;predict&lt;/code&gt; sẽ giúp bạn chạy thuật toán sau khi Train với dữ liệu Test. Đòng
cuối giúp mình tính kết quả của thuật toán dự đoán và kết quả đúng của dữ liệu Test từ đó ta có thể tiếp tục cải tiến.&lt;/p&gt;
&lt;h2 id=&#34;chốt-sổ-nào&#34;&gt;
    
        &lt;a href=&#34;#ch%e1%bb%91t-s%e1%bb%95-n%c3%a0o&#34;&gt;#&lt;/a&gt;
        Chốt sổ nào
    
&lt;/h2&gt;
&lt;p&gt;Phù, cuối cùng cũng hết rồi các bạn à. Bài viết này mình đi sâu và mình nghĩ chắc chắn các bạn sẽ có rất nhiều câu
hỏi muốn được giải đáp, vì vậy hãy chờ đón những bài viết tiếp của mình về chủ đề này nha.&lt;/p&gt;</description> 
		</item>
		
		<item>
			<title>Series Microservices: Bắt đầu với Microservices</title>
			<link>https://devot.netlify.app/posts/series-microservices-beginning-microservices/</link>
			<pubDate>Sun, 06 Mar 2022 12:51:24 +0700</pubDate>
			
			<guid>https://devot.netlify.app/posts/series-microservices-beginning-microservices/</guid>
			<description>&lt;p&gt;Có lẽ Microservices không còn là một thuật ngữ quá mới đối với Dev nữa khi mà ngày càng nhiều Framework,
Platform hỗ trợ kiến trúc này. Vì vậy, để các bạn mới bắt đầu với kiến trúc này có thể tìm hiểu về nó,
mình quyết định bắt đầu 1 Series nhỏ giới thiệu qua những khái niệm cũng như những thứ hay hó khác.
Nếu bạn đã sẵn sàng thì chúng ta bắt đầu nào.&lt;/p&gt;
&lt;h2 id=&#34;microservices-là-gì-nhỉ&#34;&gt;
    
        &lt;a href=&#34;#microservices-l%c3%a0-g%c3%ac-nh%e1%bb%89&#34;&gt;#&lt;/a&gt;
        Microservices là gì nhỉ?
    
&lt;/h2&gt;
&lt;p&gt;Khác với những kiến trúc hay những Design Pattern khi mà nó thường bao hàm cách để có thể tự mình implement
lại được. Microservices có vẻ mập mờ hơn, điểm chung lớn nhất của những người nói họ thiết kế hệ thống theo
Microservices là hệ thống gồm rất nhiều Project và chúng dùng API để giao tiếp với nhau.&lt;/p&gt;
&lt;p&gt;Sự mập mờ còn từ chữ &amp;ldquo;micro&amp;rdquo; nữa, từ này thể hiện là chúng ta cần chia hệ thống thành rất nhiều phần nhỏ,
nhưng nhỏ tới thế nào thì lại không rõ lắm. Chia nhỏ tới từng Function hay từng Class thì có vẻ không ổn lắm,
vậy kiến trúc MVC cũng chia hệ thống thành 3 phần nhỏ hơn thì có thể gọi là Microservices không nhỉ?&lt;/p&gt;
&lt;p&gt;Thậm chí nguồn gốc của kiến trúc Microservices cũng rất mập mờ. Khi mà nhiều công ty lớn về lập trình cho
rằng họ đã sử dụng kiến trúc này từ vài thập kỉ về trước, nếu như vậy xem chừng kiến trúc này cũng không
hẳn là đột phá lắm. Vậy lý do nào khiến nó được chú ý ở thời điểm hiện tại như vậy?&lt;/p&gt;
&lt;p&gt;Xem chừng dù chưa trả lời được câu hỏi Microservices là gì thì chúng ta đã gặp hàng đống vấn đề khác rồi.
Vì vậy mình nghĩ cách tiếp cận tốt nhất với Microservices là xem những ông lớn trong ngành đang dùng nó
như thế nào. Nổi tiếng nhất có thể kể tới ông lớn Netflix, không chỉ có những Series phim hay, công ty
này cũng đóng góp cho cộng đồng nhiều những Framework để implement các service trong kiến trúc Microservices.
Họ còn thuyết trình về hệ thống đó nữa, và mình recommend bạn nên xem qua nó để hình dung sơ qua
vấn đề mà Netflix đã giải quyết với kiến trúc Microservervice.&lt;/p&gt;

&lt;div style=&#34;position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;&#34;&gt;
  &lt;iframe src=&#34;https://www.youtube.com/embed/CZ3wIuvmHeM&#34; style=&#34;position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;&#34; allowfullscreen title=&#34;YouTube Video&#34;&gt;&lt;/iframe&gt;
&lt;/div&gt;

&lt;p&gt;Thì như ta thấy các Service trong kiến trúc Microservices này độc lập với nhau, chúng gọi nhau qua các
API là các protocol như HTTP, GRPC, Thrift, Websocket hay những cơ chế Pub/Sub. Các Service này cũng
có tính đóng gói để dễ dàng đóng thành các Container riêng. Các Service này cũng xử lý logic, business
hoặc trung chuyển dữ liệu, chúng có thể sử dụng DB hoặc không.&lt;/p&gt;
&lt;p&gt;Thì với cách hiểu ở trên thì rõ ràng không hề có 1 chỗ nào nói các Service sẽ phải nhỏ cả, mình nghĩ
đây là một nhầm lẫn mà ta thường gặp phải.&lt;/p&gt;
&lt;h2 id=&#34;chuẩn-bị-nguyên-liệu-chính&#34;&gt;
    
        &lt;a href=&#34;#chu%e1%ba%a9n-b%e1%bb%8b-nguy%c3%aan-li%e1%bb%87u-ch%c3%adnh&#34;&gt;#&lt;/a&gt;
        Chuẩn bị nguyên liệu chính
    
&lt;/h2&gt;
&lt;p&gt;Để làm gỏi món Microservices này, thì mình nghĩ một số nguyên liệu sau đây có thể sẽ rất là cần thiết.
Tất nhiên là bạn có thể không cần dùng hết tất cả nếu hệ thống của bạn vẫn vận hành ổn.&lt;/p&gt;
&lt;h3 id=&#34;gateway&#34;&gt;
    
        &lt;a href=&#34;#gateway&#34;&gt;#&lt;/a&gt;
        Gateway
    
&lt;/h3&gt;
&lt;p&gt;Như mình có nói ở trên thì các Service độc lập và giao tiếp qua tầng Network, vậy trừ khi bạn quyết
định để mỗi Service publish một IP riêng ra bên ngoài vì không thể tranh nhau cùng một Port được.
Thì Gateway xem chừng là một thứ không thể thiếu được, nó sẽ handle việc Reverse Proxy cũng như Load
Balance. Mỗi Request từ phía client đều sẽ phải đi qua Gateway, và nó sẽ phần chia request tới chính
xác Service. Chính vì Gateway cũng làm việc độc lập và giao tiếp qua Network, nên Gateway thường sẽ
là một Service trong hệ thống.&lt;/p&gt;
&lt;h3 id=&#34;service-discovery&#34;&gt;
    
        &lt;a href=&#34;#service-discovery&#34;&gt;#&lt;/a&gt;
        Service Discovery
    
&lt;/h3&gt;
&lt;p&gt;Một điểm mạnh của kiến trúc Microservices đó là khả năng Scale của nó, mỗi Service độc lập, việc bạn
Scale một Service lên sẽ không ảnh hưởng tới các Service khác. Nhưng đồng thời điều này cũng mang
tới thách thức về việc các Service gọi nhau khi mà không biết được Port hoặc chí là IP của Service
sau khi Scale. Để giải quyết vấn đề này thì ta thường sẽ sử dụng một Service là Service Discovery,
nhiệm vụ chính của Service này là lưu thông tin về Port cũng như IP của tất cả Service trong hệ thống,
khi có Service cần gọi cho Service thì sẽ gửi request lên Service Discovery để tìm thông về Service
mà nó cần gọi. Do Service Discovery giải quyết một vấn đề tương đối quan trọng nên đa số hệ thống
Microservices đều sẽ có một Service làm nhiệm vụ này.&lt;/p&gt;
&lt;h2 id=&#34;chuẩn-bị-thêm-gia-vị&#34;&gt;
    
        &lt;a href=&#34;#chu%e1%ba%a9n-b%e1%bb%8b-th%c3%aam-gia-v%e1%bb%8b&#34;&gt;#&lt;/a&gt;
        Chuẩn bị thêm gia vị
    
&lt;/h2&gt;
&lt;p&gt;Để giúp món ăn Microservices được ngon thì bạn có thể sử dụng thêm một số gia vị sau đây, chúng thường
không bắt buộc nhưng giúp bạn giải quyết một số những vấn đề thường gặp trong Microservices.&lt;/p&gt;
&lt;h3 id=&#34;distributed-tracing&#34;&gt;
    
        &lt;a href=&#34;#distributed-tracing&#34;&gt;#&lt;/a&gt;
        Distributed Tracing
    
&lt;/h3&gt;
&lt;p&gt;Một vấn đề lớn khi bạn sử dụng kiến trúc Microservices đó là việc có quá nhiều kịch bản và khi có Bug,
bạn không thể Debug cả hệ thống được. Có nhiều nguyên nhân của vấn đề này, một trong đó là việc các
Service giao tiếp với nhau qua Network, thì Distributed Tracing sẽ giải quyết vấn đề này bằng cách
truy vết các request hết một vòng đời của request đó. Tất nhiên việc này sẽ làm chậm request được gửi
tới nên thường Distributed Tracing đi kèm với khả năng cấu hình phần trăm request được truy vết.&lt;/p&gt;
&lt;h3 id=&#34;circuit-breaker&#34;&gt;
    
        &lt;a href=&#34;#circuit-breaker&#34;&gt;#&lt;/a&gt;
        Circuit Breaker
    
&lt;/h3&gt;
&lt;p&gt;Đây là cầu giao của hệ thống, chúng giải quyết vấn đề về kịch bản khi có một Service bị lỗi và ngừng
hoạt động. Tuy là các Service độc lập nhưng việc các Service đột ngột không gọi cho nhau được cũng
gây ra nhiều kịch bản mới, thì Circuit Breaker giúp bạn handle bớt kịch bản liên quan tới việc
Service được gọi tối ngưng hoạt động.&lt;/p&gt;
&lt;h2 id=&#34;so-sánh&#34;&gt;
    
        &lt;a href=&#34;#so-s%c3%a1nh&#34;&gt;#&lt;/a&gt;
        So sánh
    
&lt;/h2&gt;
&lt;p&gt;Thường khi nhắc tới so sánh kiến trúc Microservices thì ta sẽ nghĩ ngay tới Monolith, điều này cũng
không lạ lắm vì 2 kiến trúc này hoàn toàn ngược nhau và việc so sánh sẽ dễ làm bật ra tính chất
của cả 2.&lt;/p&gt;
&lt;h3 id=&#34;microservices&#34;&gt;
    
        &lt;a href=&#34;#microservices&#34;&gt;#&lt;/a&gt;
        Microservices
    
&lt;/h3&gt;
&lt;h4 id=&#34;điểm-mạnh&#34;&gt;
    
        Điểm mạnh
    
&lt;/h4&gt;
&lt;p&gt;Khả năng Scale là thứ mà chắc là nhiều bạn cũng nghe quảng cáo rồi, thì kiến trúc Microservices làm
điều này rất là tốt, mỗi Service độc lập nhau nên đóng gói thành Container dễ dàng. Về mặt thay đổi
tính năng cũng tương đối dễ dàng khi chỉ cần tạo một Service mới bên cạnh các Service cũ và điều
hướng người dùng từ từ qua tính năng mới thay vì phải đóng Website để bảo trì.&lt;/p&gt;
&lt;h4 id=&#34;điểm-yếu&#34;&gt;
    
        Điểm yếu
    
&lt;/h4&gt;
&lt;p&gt;Việc tạo nhiều Service như vậy khiến chạy sản phẩm dưới Local tương đối khó khăn, nếu bạn sử dụng
Java Spring Boot thì sẽ bị choáng với lượng Ram mà cả hệ thống cần do mỗi Service lại cần 1 JVM
riêng, Garbage Collector riêng. Do các ngôn ngữ đều tối ưu cho chính Project biên dịch thôi, nên
việc chạy hệ thống gồm nhiều Project sẽ tốn nhiều tài nguyên hơn chạy một Project lớn. CI/CD cho
Microservices cũng tốn thời gian nhiều hơn và từ đó chi phí vận hành hệ thống cũng tăng lên.&lt;/p&gt;
&lt;p&gt;Việc các Service giao tiếp với nhau qua Network cũng tăng độ Delay của hệ thống khi xử lý Request
của Client. Ngoài ra cách giao tiếp này cũng rất khó Debug cũng như tìm ra lỗi, khi một Request có
thể phải đi qua nhiều Service tạo ra nhiều kịch bản khác nhau.&lt;/p&gt;
&lt;h3 id=&#34;monolith&#34;&gt;
    
        &lt;a href=&#34;#monolith&#34;&gt;#&lt;/a&gt;
        Monolith
    
&lt;/h3&gt;
&lt;p&gt;Ngược lại với cái trên nên thôi mình không ghi nha 😅.&lt;/p&gt;
&lt;h2 id=&#34;tổng-kết-thôi&#34;&gt;
    
        &lt;a href=&#34;#t%e1%bb%95ng-k%e1%ba%bft-th%c3%b4i&#34;&gt;#&lt;/a&gt;
        Tổng kết thôi
    
&lt;/h2&gt;
&lt;p&gt;Bài viết đầu tiên trong Series mang tính chủ yếu là thảo luận về Microservices, trả lời một số
câu hỏi có thể các bạn thắc mắc. Cùng như giới thiệu một vài khái niệm sẽ được làm rõ hơn trong
những bài viết sau.&lt;/p&gt;</description> 
		</item>
		
	</channel>
</rss>

